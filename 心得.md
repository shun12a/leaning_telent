### 22.11.21 	

	**指针名也可以用来当地址**。C语言默认会把数组转换为指针来进行操作.所以两者几乎等价。为了书写 方便便用数组来代替。

### 22.11.22 
	1.系统调用的错误一般都会放在error里,error里是记录系统最后一次的错误代码	
	2.结构体可以只对其中一个变量进行初始话,其余的变量由系统自动分配初始化
	3.A ? a: B ? b : C ? c : "ddd" 

### 22.11.23
	1.adb可远程链接Android手机内存或是开发板
	2.蓝色:目录 绿色:可执行文件 红色:压缩文件 浅蓝色:链接文件 白色:普通文件 黄色:设备文件

### 22.11.24
	1.typedef void(*fun)(void); 定义了一个fun的函数类型
	2.typedef   int   int32;
	  unsigned   INT32   j = 10;
	   **编译出错，我也不知道这是为什么，估计编译器将这句话理解为：unsigned ( int )   int  j =10; 即INT32代表的 int  和unsigned ( int ) 是两次声明，所以出错。**
	3.swicth只能对整形进行判断,不能对字符型进行判断

### 22.11.25
	1.指针可以赋值
	2.指针如果NULL，指针指向空间不可复制。
	变参函数:
			/*【第一步】:定义一个使用省略号的函数原型 */
			double sum(int lim, ...) {
				/*【第二步】:声明一个va_list类型的变量ap */
				va_list ap;
				double sum;
				int i;
				/*【第三步】:使用va_start把变量ap初始化为参数列表 */
				va_start(ap, lim); 
				for (i = 0; i < lim; i++){
					 /*【第四步】: 使用va_arg访问参数列表。 
   这里第二个参数是double类型，传入的不定参数就应是double类型
   */
					 sum += va_arg(ap, double);  
				}
				va_end(ap); 
				return sum;
			}
			

			int main(void)
			{
 				double sum1 = 0, sum2 = 0;
 				/* 计算 */
 				sum1 = sum(3, 1.1, 2.2, 3.3);  
 				sum2 = sum(6, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0);
 				printf("sum1 = %f\n", sum1);
 				printf("sum2 = %f\n", sum2);
				return 0;
			}

	3.vi -r *swp 将所有.swp写入原来的文件中
		rm -rf *.swp

	4.使用vsnprintf()用于向一个字符串缓冲区打印格式化字符串，且可以限定打印的格式化字符串的最大长度。
	int vsnprintf (char * sbuf, size_t n, const char * format, va_list arg );

### 22.11.26
	1.看了一些Java相关的知识,比如所scareen类的打印消息,标识符char int short long double等等,三目运算符的打印
	2.java与c++的面向对象更为彻底一些,现在我才发现c++保留的c是真的多,但也更为方便一些.
	3.在B站查看了一些日志架构的代码,但是并没有什么用,讲的我感到真的
	不懂

### 22.11.27
	1.在github上查看了日志的代码,更着敲了一边.有个更难的看了半天.
	2.感觉上班了过后好无聊,在这边没什么人聊天.晚上打会游戏.
	3.为什么需要日志,因为日志就像游戏中角色的武器,武器强大与适合才是最厉害的.没有日志就无法更方便查看变量的运行变化.
	4.#error 预处理指令的作用: 编译程序时,只要遇到#error就会生成一个编译错误提示消息,并停止编译.

### 22.11.28
	1.指针在未初始化时不会分配内存空间,指向的地址不明确,就会报出异常.所以指针声明必须初始化.
	2.在使用 gethostbyname() 查找域名的时候，你不能用perror() 打印错误信息(因为 errno 没有使用)，你应该调用 herror()。

### 22.11.29
	1.gcc 函数属性	__nothrow__属性告诉我们编译器不能抛出异常
	2.__leaf__属性表示不会调用其他任何函数
	3.noreturn属性表示函数不能返回,少数标准库函数会用上abort和exit
	4.#define THROW __attribute__((__nothrow__ __LEAF)) #define __LEAF __leaf__
	5.我们在删除一个指针之后，编译器只会释放该指针所指向的内存空间，而不会删除这个指针本身。在删除一个指针之后，一定将该指针设置成空指针（即在delete *p之后一定要加上： p=NULL）
	6.传入的是地址常量就无法改变,只能通过二级指针将指向改变.
	7.char *str[9] = {[0] = "Mary", [1 ... 7] = "Lily", [8] = "Sarry"};
	8.字符串编译器会动态在其末尾加上'\0',所以初始化时应该小心一点
	9.C语言中sizeof()是标识符,存在于<stdio.h>中,并不是函数.

### 22.11.30
	1.calloc会在申请内存过后自动为其初始化
	2.relloc会为calloc和malloc申请的空间后面进行扩容的操作,返回值为指向新分配内存的指针.
	3.C语言传入的形参不能为NULL,因为NULL空间是不可操作的.
	4.strstr(char *str1, const char *str2)函数返回首次出现子串的地址.
	5.fgets()函数可以从stream流中读取size个字符存储到字符指针变量所指向的内存空间中.
	6.你可能想检查一下valgrind（免费！）——它“自动检测[s]许多内存管理和线程错误，并详细分析你的程序。” 它不是静态检查器，但它是一个很棒的工具！
	7.您可以使用cppcheck。它是一个易于使用的静态代码分析工具。
	8.Sparse是一种计算机软件工具，已经在 Linux 上可用，旨在发现 Linux 内核中可能存在的编码错误。
	9.C 库函数 size_t strcspn(const char *str1, const char *str2) 检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。
	10.fstat函数由文件描述符得文件状态
	11.IIRC 标准库定义off_t为无符号 64 位整数，这是每个人都应该使用的。几年后，当我们开始有 16 个 EB 文件时，我们可以将其重新定义为 128 位。
	12. long int strtol(const char *str, char **endptr, int base) 把参数 str 所指向的字符串根据给定的 base 转换为一个长整数（类型为 long int 型），base 必须介于 2 和 36（包含）之间，或者是特殊值 0。
	13.  unsigned long int strtoul(const char *str, char **endptr, int base) 把参数 str 所指向的字符串根据给定的 base 转换为一个无符号长整数（类型为 unsigned long int 型），base 必须介于 2 和 36（包含）之间，或者是特殊值 0。
	14. usleep函数是用于线程挂起一段时间的函数,单位是微秒.
	15. fgets()函数的功能是从 stream 流中读取 size 个字符存储到字符指针变量 s 所指向的内存空间。它的返回值是一个指针，指向字符串中第一个字符的地址。如果读取的长度小于字符串的长度，字符串就会被截断。如果大于字符串的长度，超过的部分就会补充'\0'.
	